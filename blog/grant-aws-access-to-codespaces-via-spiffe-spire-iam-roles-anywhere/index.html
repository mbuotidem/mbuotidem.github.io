<!DOCTYPE html>
<html lang="en" >

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta name="base" content="https://misaac.me">

    
    <title>Isaac on DevSecOps • Grant AWS Access to GitHub Codespaces via SPIFFE/SPIRE & IAM Roles Anywhere</title>

    
    
    

    
    

    
    
    
        <link rel="stylesheet" href="https://misaac.me/inter_subset_en.css?h=d8cf4ad058d6c3a4015b">
    

    
        <link rel="stylesheet" href="https://misaac.me/main.css?h=f8b119c70beffb77ac87" />

    <meta name="color-scheme" content="light dark" />
        <meta name="description" content="Learn how to authenticate your GitHub Codespace to AWS using SPIRE-issued X.509 certificates and AWS IAM Roles Anywhere" />
        <meta property="og:description" content="Learn how to authenticate your GitHub Codespace to AWS using SPIRE-issued X.509 certificates and AWS IAM Roles Anywhere" />

    
        <meta name="robots" content="index, nofollow" />
    

    <meta property="og:title" content="Grant AWS Access to GitHub Codespaces via SPIFFE/SPIRE & IAM Roles Anywhere" />
    <meta property="og:type" content="article" />

    
<meta property="og:locale" content="en_GB" />

    <meta property="og:url" content="https:&#x2F;&#x2F;misaac.me&#x2F;blog&#x2F;grant-aws-access-to-codespaces-via-spiffe-spire-iam-roles-anywhere&#x2F;" /><meta property="og:site_name" content="Isaac on DevSecOps"><meta http-equiv="Content-Security-Policy"
content="default-src 'self';font-src &#x27;self&#x27; data:;img-src &#x27;self&#x27; https:&#x2F;&#x2F;* data:;media-src &#x27;self&#x27;;style-src &#x27;self&#x27; https:&#x2F;&#x2F;emgithub.com &#x27;unsafe-inline&#x27; https:&#x2F;&#x2F;emgithub.misaac.me &#x27;unsafe-inline&#x27; https:&#x2F;&#x2F;gist.github.com &#x27;unsafe-inline&#x27; https:&#x2F;&#x2F;github.githubassets.com &#x27;unsafe-inline&#x27;;frame-src player.vimeo.com https:&#x2F;&#x2F;www.youtube-nocookie.com https:&#x2F;&#x2F;emgithub.com https:&#x2F;&#x2F;emgithub.misaac.me;connect-src 'self';script-src 'self' 'self' https://gist.github.com">

        <noscript><link rel="stylesheet" href="https://misaac.me/no_js.css"/></noscript>
        <script type="text/javascript" src="https://misaac.me/js/initializeTheme.min.js"></script>
        <script defer src="https://misaac.me/js/themeSwitcher.min.js"></script></head>


<body class="use-sans-serif">
    <header>
    <nav class="navbar">
        <div class="nav-title">
            <a class="home-title" href="https://misaac.me">Isaac on DevSecOps</a>
        </div>
            <div class="nav-navs">
                <ul>
                        
                            <li>
                                
                                
                                    <a class="nav-links no-hover-padding" href="https://misaac.me/blog/">
                                
                                blog
                                </a>
                            </li>
                        
                            <li>
                                
                                
                                    <a class="nav-links no-hover-padding" href="https:&#x2F;&#x2F;www.linkedin.com&#x2F;in&#x2F;miisaac&#x2F;" target="_blank" rel="noopener noreferrer">
                                
                                linkedin
                                </a>
                            </li>
                        
                            <li>
                                
                                
                                    <a class="nav-links no-hover-padding" href="https:&#x2F;&#x2F;github.com&#x2F;mbuotidem&#x2F;" target="_blank" rel="noopener noreferrer">
                                
                                github
                                </a>
                            </li>
                        
                            <li>
                                
                                
                                    <a class="nav-links no-hover-padding" href="https://misaac.me/tags/">
                                
                                tags
                                </a>
                            </li>
                        <div class="nav-navs" id="menu-icons-group">
                        

                        
                        

                        <li class="theme-switcher-wrapper js"><div
        title="Toggle dark&#x2F;light mode"
        class="theme-switcher"
        tabindex="0"
        role="button"
        aria-label="Toggle dark mode"
        aria-pressed="false">
    </div><div
        title="Reset mode to default"
        class="theme-resetter arrow"
        tabindex="0"
        role="button"
        aria-hidden="true"
        aria-label="Reset mode to default">
    </div>

</li>
</div>
                </ul>
            </div>
        
    </nav>
</header>

    <div class="content">

        
        




<main>
    <article>
        <h1 class="article-title">
            Grant AWS Access to GitHub Codespaces via SPIFFE&#x2F;SPIRE &amp; IAM Roles Anywhere
        </h1>

        <ul class="meta">
                <li>19th May 2025</li>
                <li title="3599 words"><span class='separator' aria-hidden='true'>•</span>18 min read</li><li class="tag"><span class='separator' aria-hidden='true'>•</span>Tags:&nbsp;</li><li class="tag"><a href="https://misaac.me/tags/spiffe-spire/">spiffe&#x2F;spire</a>,&nbsp;</li><li class="tag"><a href="https://misaac.me/tags/identity/">identity</a>,&nbsp;</li><li class="tag"><a href="https://misaac.me/tags/secrets-management/">secrets management</a>,&nbsp;</li><li class="tag"><a href="https://misaac.me/tags/zero-trust/">zero trust</a>,&nbsp;</li><li class="tag"><a href="https://misaac.me/tags/aws/">aws</a>,&nbsp;</li><li class="tag"><a href="https://misaac.me/tags/codespaces/">codespaces</a>,&nbsp;</li><li class="tag"><a href="https://misaac.me/tags/iam/">iam</a>,&nbsp;</li><li class="tag"><a href="https://misaac.me/tags/terraform/">terraform</a>,&nbsp;</li><li class="tag"><a href="https://misaac.me/tags/github/">github</a>,&nbsp;</li><li class="tag"><a href="https://misaac.me/tags/iac/">iac</a></li>
        </ul>

        <section class="body"><h2 id="preamble"><a class="header-anchor no-hover-padding" href="#preamble" aria-label="Anchor link for: preamble"><span class="link-icon" aria-hidden="true"></span></a>
Preamble</h2>
<p>In our <a href="https://misaac.me/blog/spiffe-spire-secret-sprawl-fix/">intro post</a>, we discussed why <a href="https://spiffe.io/">SPIFFE/SPIRE</a> might just be the right identity foundation for your org. SPIFFE is the open standard, while SPIRE is the reference implementation.</p>
<p>As a refresher, SPIFFE/SPIRE solves the secret zero problem, namely, how do I securely bootstrap trust of a workload, without first giving it a secret? SPIFFE does this by requiring that implementations provide a mechanism for workloads to request an x.509 certificate using only properties that are inherently available in the environment the workload is running on.</p>
<p>To acheive this securely, SPIRE has both workloads and the nodes they run on  perform <a href="https://spiffe.io/docs/latest/spire-about/spire-concepts/#attestation">attestation</a> using out-of-band authenticity checks. In other words, it checks that a workload <strong>is truly running</strong> on the environment it claims by verifying platform-specific properties such as AWS instance metadata, Kubernetes service account tokens, or other environment specific metadata it can obtain. Its like having a cool friend that gets you on the guest list at a hard to enter club in Berlin - the workload just has to show up as itself, and if its on the list, it'll get the certificate.</p>
<p>In this post, we'll be focusing on one possible use case - letting our GitHub Codespace environments authenticate to AWS via AWS IAM Roles Anywhere.</p>
<br>
<h2 id="terminology"><a class="header-anchor no-hover-padding" href="#terminology" aria-label="Anchor link for: terminology"><span class="link-icon" aria-hidden="true"></span></a>
Terminology</h2>
<p>Here's a brief guide to key terms used in this post:</p>
<p><strong>SPIFFE (Secure Production Identity Framework for Everyone):</strong> A universal standard for securely issuing identities to workloads, enabling them to prove their identity without managing traditional secrets.</p>
<p><strong>SPIRE (SPIFFE Runtime Environment):</strong> An open-source implementation of SPIFFE, responsible for issuing identities to workloads and verifying their authenticity.</p>
<p><strong>PKI (Public Key Infrastructure):</strong> A system used for generating, managing, distributing, and revoking digital certificates and associated cryptographic keys.</p>
<p><strong>mTLS (Mutual TLS):</strong> A variation of the Transport Layer Security (TLS) protocol, requiring both the client and server to verify each other's identity through cryptographic certificates.</p>
<p><strong>IAM Roles Anywhere:</strong> An AWS service that extends AWS Identity and Access Management (IAM) roles to workloads running outside AWS environments, enabling secure and temporary credential generation based on external certificates.</p>
<p><strong>Attestation:</strong> The cryptographic process used to verify that a workload or node truly is what it claims to be, often by validating metadata provided by cloud providers or system environments.</p>
<p><strong>SVID (SPIFFE Verifiable Identity Document):</strong> A short-lived, cryptographically verifiable certificate or token containing a unique SPIFFE ID, used by workloads to securely authenticate their identity.</p>
<p><strong>Node Attestation:</strong> A secure procedure used by SPIRE to confirm the identity of nodes (e.g., servers, virtual machines, or containers) before issuing credentials.</p>
<p><strong>Workload Attestation:</strong> A process where SPIRE verifies the identity of an individual workload, typically by inspecting attributes like Unix user IDs, Kubernetes service accounts, or other environment-specific metadata.</p>
<p><strong>Trust Anchor:</strong> A trusted entity, such as a root certificate authority, used as a starting point in establishing cryptographic trust chains. When a CA is a trust anchor, it means that a system can trust the CA to sign certificates that it can, in turn, trust.</p>
<p><strong>Selector:</strong> Attributes defined in SPIRE registration entries used to recognize and verify workloads, such as Unix user IDs or Kubernetes labels.</p>
<br>
<h2 id="what-s-our-goal"><a class="header-anchor no-hover-padding" href="#what-s-our-goal" aria-label="Anchor link for: what-s-our-goal"><span class="link-icon" aria-hidden="true"></span></a>
What's our goal?</h2>
<p>Our goal is gain access to AWS from our GitHub Codespace using a SPIRE issued X.509 certificate, also known as <a href="https://spiffe.io/docs/latest/spire-about/spire-concepts/#a-day-in-the-life-of-an-svid">SVIDs</a>. To do this, we will :</p>
<ul>
<li>set up our PKI</li>
<li>set up IAM Roles Anywhere</li>
<li>set up a SPIRE Server on AWS that will register itself with IAM Roles Anywhere</li>
<li>fire up a local SPIRE agent to listen for SPIFFE SVID x.509 certificate requests</li>
<li>request a certificate (SVID)</li>
<li>use that certificate to obtain AWS credentials via IAM Roles Anywhere</li>
</ul>
<h2 id="setting-up-our-public-key-infrastructure-pki"><a class="header-anchor no-hover-padding" href="#setting-up-our-public-key-infrastructure-pki" aria-label="Anchor link for: setting-up-our-public-key-infrastructure-pki"><span class="link-icon" aria-hidden="true"></span></a>
Setting up our Public Key Infrastructure (PKI)</h2>
<p>By default, the SPIRE server can act as its own certificate authority. However because we want to use this SPIRE server as our universal identity control plane, we will instead set it up to use our own PKI system as this will help support future integrations. Through its robust plugin system, SPIRE lets us set our own <code>UpstreamAuthority</code>. Let's spin up a quick-and-dirty PKI using Terraform.</p>
<pre class="z-code"><code><span class="z-text z-plain"># 1. Root CA Private Key
</span><span class="z-text z-plain">resource &quot;tls_private_key&quot; &quot;root_ca_key&quot; {
</span><span class="z-text z-plain">  algorithm = &quot;RSA&quot;
</span><span class="z-text z-plain">  rsa_bits  = 2048
</span><span class="z-text z-plain">}
</span><span class="z-text z-plain">
</span><span class="z-text z-plain"># 2. Root CA Self-Signed Certificate
</span><span class="z-text z-plain">resource &quot;tls_self_signed_cert&quot; &quot;root_ca_cert&quot; {
</span><span class="z-text z-plain">  private_key_pem = tls_private_key.root_ca_key.private_key_pem
</span><span class="z-text z-plain">
</span><span class="z-text z-plain">  subject {
</span><span class="z-text z-plain">    common_name  = &quot;misaac.me Root CA&quot;
</span><span class="z-text z-plain">    organization = &quot;Misaac Org&quot;
</span><span class="z-text z-plain">    country      = &quot;US&quot;
</span><span class="z-text z-plain">  }
</span><span class="z-text z-plain">
</span><span class="z-text z-plain">  is_ca_certificate = true
</span><span class="z-text z-plain">  validity_period_hours = 87600 # 10 years
</span><span class="z-text z-plain">
</span><span class="z-text z-plain">  allowed_uses = [
</span><span class="z-text z-plain">    &quot;cert_signing&quot;,
</span><span class="z-text z-plain">    &quot;crl_signing&quot;,
</span><span class="z-text z-plain">    &quot;key_encipherment&quot;,
</span><span class="z-text z-plain">    &quot;digital_signature&quot;,
</span><span class="z-text z-plain">  ]
</span><span class="z-text z-plain">
</span><span class="z-text z-plain">}
</span></code></pre>
<p>Next we'll store this information in AWS Secret Manager as its one of the available <code>UpstreamAuthority</code> sources <a href="https://github.com/spiffe/spire/blob/v1.12.0/doc/plugin_server_upstreamauthority_awssecret.md">supported by SPIRE</a>.</p>
<pre class="z-code"><code><span class="z-text z-plain">resource &quot;aws_secretsmanager_secret&quot; &quot;upstream_authority_cert_file&quot; {
</span><span class="z-text z-plain">  name                    = &quot;spire_cert_file&quot;
</span><span class="z-text z-plain">  recovery_window_in_days = 0
</span><span class="z-text z-plain">}
</span><span class="z-text z-plain">
</span><span class="z-text z-plain">resource &quot;aws_secretsmanager_secret_version&quot; &quot;upstream_authority_cert_file&quot; {
</span><span class="z-text z-plain">  secret_id                = aws_secretsmanager_secret.upstream_authority_cert_file.id
</span><span class="z-text z-plain">  secret_string_wo         = tls_self_signed_cert.root_ca_cert.cert_pem
</span><span class="z-text z-plain">  secret_string_wo_version = 12
</span><span class="z-text z-plain">}
</span><span class="z-text z-plain">
</span><span class="z-text z-plain">resource &quot;aws_secretsmanager_secret&quot; &quot;upstream_authority_key_file&quot; {
</span><span class="z-text z-plain">  name                    = &quot;spire_key_file&quot;
</span><span class="z-text z-plain">  recovery_window_in_days = 0
</span><span class="z-text z-plain">}
</span><span class="z-text z-plain">
</span><span class="z-text z-plain">resource &quot;aws_secretsmanager_secret_version&quot; &quot;upstream_authority_key_file&quot; {
</span><span class="z-text z-plain">  secret_id                = aws_secretsmanager_secret.upstream_authority_key_file.id
</span><span class="z-text z-plain">  secret_string_wo         = tls_private_key.root_ca_key.private_key_pem
</span><span class="z-text z-plain">  secret_string_wo_version = 12
</span><span class="z-text z-plain">}
</span></code></pre>
<p>Using Terraform as your PKI will likely not win you security awards, and if you don't already have a production grade PKI, you can always use AWS ACM Private Certificate Authority via the <a href="https://github.com/spiffe/spire/blob/v1.12.0/doc/plugin_server_upstreamauthority_aws_pca.md"><code>aws_pca</code></a> plugin.</p>
<p>It is worth mentioning however that AWS PCA costs at minimum <a href="https://aws.amazon.com/private-ca/pricing/">$400 a month</a> unless you use the short-lived certificate mode. And while the short-lived certificate mode does work with SPIRE, you need to make sure that your scenarios support certificates with such a short (7 days) validity period. For example, AWS Client VPN, one of the services we intend to support, <a href="https://repost.aws/questions/QUJNVBimQVQjW7L7DHRFaxQQ#ANzORcy-x6RcaVWg2gqeLZUA">doesn't</a>.</p>
<br>
<h2 id="setting-up-iam-roles-anywhere"><a class="header-anchor no-hover-padding" href="#setting-up-iam-roles-anywhere" aria-label="Anchor link for: setting-up-iam-roles-anywhere"><span class="link-icon" aria-hidden="true"></span></a>
Setting up IAM Roles Anywhere</h2>
<p>To use IAM Roles Anywhere, we need a configured trust anchor, an IAM role that will be assumed, and an IAM Roles Anywhere profile. Notice how we set <code>source_data</code> to the root cert of our PKI, but then add an <code>ignore_changes</code> directive. That's because once our SPIRE server is setup, it will update the trust anchor to point to the SPIRE intermediate CA it creates. When a workload requests AWS credentials, IAM Roles Anywhere will check if the workload's X.509 certificate was issued by our SPIRE server, i.e signed by SPIRE's intermediate CA. If so, IAM Roles Anywhere provides the credentials.</p>
<pre class="z-code"><code><span class="z-text z-plain">resource &quot;aws_rolesanywhere_trust_anchor&quot; &quot;iamra&quot; {
</span><span class="z-text z-plain">  name = &quot;spire-trust-anchor&quot;
</span><span class="z-text z-plain">  source {
</span><span class="z-text z-plain">    source_data {
</span><span class="z-text z-plain">      x509_certificate_data = tls_self_signed_cert.root_ca_cert.cert_pem
</span><span class="z-text z-plain">    }
</span><span class="z-text z-plain">    source_type = &quot;CERTIFICATE_BUNDLE&quot;
</span><span class="z-text z-plain">  }
</span><span class="z-text z-plain">  lifecycle {
</span><span class="z-text z-plain">    ignore_changes = [source[0].source_data[0].x509_certificate_data]
</span><span class="z-text z-plain">  }
</span><span class="z-text z-plain">  enabled = true
</span><span class="z-text z-plain">}
</span><span class="z-text z-plain">
</span><span class="z-text z-plain">resource &quot;aws_iam_role&quot; &quot;iamra&quot; {
</span><span class="z-text z-plain">  name = &quot;iamra&quot;
</span><span class="z-text z-plain">  path = &quot;/&quot;
</span><span class="z-text z-plain">
</span><span class="z-text z-plain">  assume_role_policy = jsonencode({
</span><span class="z-text z-plain">    Version = &quot;2012-10-17&quot;
</span><span class="z-text z-plain">    Statement = [{
</span><span class="z-text z-plain">      Action = [
</span><span class="z-text z-plain">        &quot;sts:AssumeRole&quot;,
</span><span class="z-text z-plain">        &quot;sts:TagSession&quot;,
</span><span class="z-text z-plain">        &quot;sts:SetSourceIdentity&quot;
</span><span class="z-text z-plain">      ]
</span><span class="z-text z-plain">      Principal = {
</span><span class="z-text z-plain">        Service = &quot;rolesanywhere.amazonaws.com&quot;,
</span><span class="z-text z-plain">      }
</span><span class="z-text z-plain">      Effect = &quot;Allow&quot;
</span><span class="z-text z-plain">      Sid    = &quot;&quot;
</span><span class="z-text z-plain">    }]
</span><span class="z-text z-plain">  })
</span><span class="z-text z-plain">}
</span><span class="z-text z-plain">
</span><span class="z-text z-plain">resource &quot;aws_rolesanywhere_profile&quot; &quot;iamra&quot; {
</span><span class="z-text z-plain">
</span><span class="z-text z-plain">  name      = &quot;example&quot;
</span><span class="z-text z-plain">  role_arns = [aws_iam_role.iamra.arn]
</span><span class="z-text z-plain">  enabled   = true
</span><span class="z-text z-plain">}
</span></code></pre>
<p>Note that we don't grant this IAM role any permissions at this time. So the most we'll be able to do with it once assumed is run <code>aws-get-caller-identity</code>. But that's sufficient for us to verify that our plumbing works.</p>
<br>
<h2 id="setting-up-the-spire-server"><a class="header-anchor no-hover-padding" href="#setting-up-the-spire-server" aria-label="Anchor link for: setting-up-the-spire-server"><span class="link-icon" aria-hidden="true"></span></a>
Setting up the SPIRE Server</h2>
<p>While most people running SPIRE will likely be running it on Kubernetes, for the purposes of this series, we'll keep things simple and use ECS.</p>
<h3 id="architecture"><a class="header-anchor no-hover-padding" href="#architecture" aria-label="Anchor link for: architecture"><span class="link-icon" aria-hidden="true"></span></a>
Architecture</h3>
<p>Below is our proposed setup:</p>
<p><img src="https://misaac.me/blog/grant-aws-access-to-codespaces-via-spiffe-spire-iam-roles-anywhere/spire-on-aws-ecs-architecture.png" alt="Image showing one way to deploy the SPIRE Server on AWS using ECS" /></p>
<p>Here's how the solution works :</p>
<ol>
<li>A Route 53 record holds the address that SPIRE agents will reach the SPIRE server on</li>
<li>The Route 53 record will point to a Network Load Balancer (NLB) deployed in our public subnet</li>
<li>This Network Load Balancer routes traffic to the SPIRE server hosted on an ECS Fargate service in a private subnet</li>
</ol>
<p>We choose a Network Load Balancer to allow for SSL passthrough as this is required for the SPIRE server and agent to complete their mTLS handshake.</p>
<h3 id="prerequisites"><a class="header-anchor no-hover-padding" href="#prerequisites" aria-label="Anchor link for: prerequisites"><span class="link-icon" aria-hidden="true"></span></a>
Prerequisites</h3>
<p>The terraform code below assumes the existence of the following:</p>
<ul>
<li>AWS VPC with both public and private subnets</li>
<li>A Route 53 hosted zone</li>
</ul>
<h3 id="setting-up-route53-and-the-network-load-balancer"><a class="header-anchor no-hover-padding" href="#setting-up-route53-and-the-network-load-balancer" aria-label="Anchor link for: setting-up-route53-and-the-network-load-balancer"><span class="link-icon" aria-hidden="true"></span></a>
Setting up Route53 and the Network Load Balancer</h3>
<p>Pick a name for your record and then make sure you choose <code>network</code> as the load balancer type and <code>ip</code> as the target group listener <code>target_type</code>.</p>
<pre class="z-code"><code><span class="z-text z-plain">resource &quot;aws_route53_record&quot; &quot;alb&quot; {
</span><span class="z-text z-plain">  zone_id = aws_route53_zone.primary.zone_id
</span><span class="z-text z-plain">  name    = &quot;spire.misaac.me&quot;
</span><span class="z-text z-plain">  type    = &quot;A&quot;
</span><span class="z-text z-plain">
</span><span class="z-text z-plain">  alias {
</span><span class="z-text z-plain">    name                   = module.alb.dns_name
</span><span class="z-text z-plain">    zone_id                = module.alb.zone_id
</span><span class="z-text z-plain">    evaluate_target_health = true
</span><span class="z-text z-plain">  }
</span><span class="z-text z-plain">}
</span><span class="z-text z-plain">
</span><span class="z-text z-plain">module &quot;alb&quot; {
</span><span class="z-text z-plain">  source  = &quot;terraform-aws-modules/alb/aws&quot;
</span><span class="z-text z-plain">  version = &quot;9.16.0&quot; # Latest version as of April 2025
</span><span class="z-text z-plain">
</span><span class="z-text z-plain">  name = &quot;misaac-me-alb&quot;
</span><span class="z-text z-plain">
</span><span class="z-text z-plain">  load_balancer_type = &quot;network&quot;
</span><span class="z-text z-plain">  vpc_id             = aws_vpc.main.id
</span><span class="z-text z-plain">  subnets            = [aws_subnet.public_subnet_a.id, aws_subnet.public_subnet_b.id]
</span><span class="z-text z-plain">  security_groups    = [aws_security_group.alb_sg.id]
</span><span class="z-text z-plain">
</span><span class="z-text z-plain">
</span><span class="z-text z-plain">  listeners = {
</span><span class="z-text z-plain">    alb_listener = {
</span><span class="z-text z-plain">      port     = 8081
</span><span class="z-text z-plain">      protocol = &quot;TCP&quot;
</span><span class="z-text z-plain">      forward = {
</span><span class="z-text z-plain">        target_group_key = &quot;spire_ip&quot;
</span><span class="z-text z-plain">      }
</span><span class="z-text z-plain">    }
</span><span class="z-text z-plain">
</span><span class="z-text z-plain">  }
</span><span class="z-text z-plain">
</span><span class="z-text z-plain">  target_groups = {
</span><span class="z-text z-plain">    spire_ip = {
</span><span class="z-text z-plain">      name                 = &quot;misaac-me-tg&quot;
</span><span class="z-text z-plain">      port                 = 8081
</span><span class="z-text z-plain">      protocol             = &quot;TCP&quot;
</span><span class="z-text z-plain">      target_type          = &quot;ip&quot;
</span><span class="z-text z-plain">      deregistration_delay = 5
</span><span class="z-text z-plain">      create_attachment    = false
</span><span class="z-text z-plain">    }
</span><span class="z-text z-plain">
</span><span class="z-text z-plain">  }
</span><span class="z-text z-plain">}
</span></code></pre>
<br>
<h3 id="setting-up-our-ecs-service"><a class="header-anchor no-hover-padding" href="#setting-up-our-ecs-service" aria-label="Anchor link for: setting-up-our-ecs-service"><span class="link-icon" aria-hidden="true"></span></a>
Setting up our ECS Service</h3>
<h4 id="the-cluster"><a class="header-anchor no-hover-padding" href="#the-cluster" aria-label="Anchor link for: the-cluster"><span class="link-icon" aria-hidden="true"></span></a>
The cluster</h4>
<p>First, we create our cluster. We'll be taking advantage of community modules from the invaluable <a href="https://github.com/terraform-aws-modules">Terraform AWS modules</a> project.</p>
<pre class="z-code"><code><span class="z-text z-plain">
</span><span class="z-text z-plain">module &quot;ecs&quot; {
</span><span class="z-text z-plain">  source  = &quot;terraform-aws-modules/ecs/aws&quot;
</span><span class="z-text z-plain">  version = &quot;5.12.1&quot; # Latest version as of April 2025
</span><span class="z-text z-plain">
</span><span class="z-text z-plain">  cluster_name = &quot;misaac-me-cluster&quot;
</span><span class="z-text z-plain">
</span><span class="z-text z-plain">  # Capacity providers
</span><span class="z-text z-plain">  fargate_capacity_providers = {
</span><span class="z-text z-plain">    FARGATE = {
</span><span class="z-text z-plain">      default_capacity_provider_strategy = {
</span><span class="z-text z-plain">        weight = 100
</span><span class="z-text z-plain">      }
</span><span class="z-text z-plain">    }
</span><span class="z-text z-plain">  }
</span><span class="z-text z-plain">
</span><span class="z-text z-plain">}
</span></code></pre>
<br>
<h4 id="the-log-groups-and-iam-roles"><a class="header-anchor no-hover-padding" href="#the-log-groups-and-iam-roles" aria-label="Anchor link for: the-log-groups-and-iam-roles"><span class="link-icon" aria-hidden="true"></span></a>
The log groups and IAM roles</h4>
<p>Next, we set up the log groups and IAM Roles that our task will need. Nothing revolutionary here, we use the managed policies and allow ECS access to perform actions on our behalf.</p>
<pre class="z-code"><code><span class="z-text z-plain"># CloudWatch Logs Group for ECS Task
</span><span class="z-text z-plain">resource &quot;aws_cloudwatch_log_group&quot; &quot;spire&quot; {
</span><span class="z-text z-plain">  name              = &quot;/ecs/misaac-me-spire&quot;
</span><span class="z-text z-plain">  retention_in_days = 30
</span><span class="z-text z-plain">
</span><span class="z-text z-plain">}
</span><span class="z-text z-plain">
</span><span class="z-text z-plain"># IAM Role for ECS Task Execution
</span><span class="z-text z-plain">resource &quot;aws_iam_role&quot; &quot;ecs_execution_role&quot; {
</span><span class="z-text z-plain">  name = &quot;ecs-execution-role&quot;
</span><span class="z-text z-plain">
</span><span class="z-text z-plain">  assume_role_policy = jsonencode({
</span><span class="z-text z-plain">    Version = &quot;2012-10-17&quot;
</span><span class="z-text z-plain">    Statement = [
</span><span class="z-text z-plain">      {
</span><span class="z-text z-plain">        Action = &quot;sts:AssumeRole&quot;
</span><span class="z-text z-plain">        Effect = &quot;Allow&quot;
</span><span class="z-text z-plain">        Principal = {
</span><span class="z-text z-plain">          Service = &quot;ecs-tasks.amazonaws.com&quot;
</span><span class="z-text z-plain">        }
</span><span class="z-text z-plain">      }
</span><span class="z-text z-plain">    ]
</span><span class="z-text z-plain">  })
</span><span class="z-text z-plain">
</span><span class="z-text z-plain">}
</span><span class="z-text z-plain">
</span><span class="z-text z-plain"># Attach required policies for ECS Task Execution Role
</span><span class="z-text z-plain">resource &quot;aws_iam_role_policy_attachment&quot; &quot;ecs_execution_role_policy&quot; {
</span><span class="z-text z-plain">  role       = aws_iam_role.ecs_execution_role.name
</span><span class="z-text z-plain">  policy_arn = &quot;arn:aws:iam::aws:policy/service-role/AmazonECSTaskExecutionRolePolicy&quot;
</span><span class="z-text z-plain">}
</span><span class="z-text z-plain">
</span><span class="z-text z-plain"># IAM Role for ECS Task
</span><span class="z-text z-plain">resource &quot;aws_iam_role&quot; &quot;ecs_task_role&quot; {
</span><span class="z-text z-plain">  name = &quot;ecs-task-role&quot;
</span><span class="z-text z-plain">
</span><span class="z-text z-plain">  assume_role_policy = jsonencode({
</span><span class="z-text z-plain">    Version = &quot;2012-10-17&quot;
</span><span class="z-text z-plain">    Statement = [
</span><span class="z-text z-plain">      {
</span><span class="z-text z-plain">        Action = &quot;sts:AssumeRole&quot;
</span><span class="z-text z-plain">        Effect = &quot;Allow&quot;
</span><span class="z-text z-plain">        Principal = {
</span><span class="z-text z-plain">          Service = &quot;ecs-tasks.amazonaws.com&quot;
</span><span class="z-text z-plain">        }
</span><span class="z-text z-plain">      }
</span><span class="z-text z-plain">    ]
</span><span class="z-text z-plain">  })
</span><span class="z-text z-plain">
</span><span class="z-text z-plain">}
</span></code></pre>
<br>
<h4 id="the-iam-policies"><a class="header-anchor no-hover-padding" href="#the-iam-policies" aria-label="Anchor link for: the-iam-policies"><span class="link-icon" aria-hidden="true"></span></a>
The IAM Policies</h4>
<p>With our roles setup, we can define the IAM policies that should be attached, namely:</p>
<ol>
<li>Grant our SPIRE server read access to the PKI info we stored in AWS secret manager</li>
<li>Grant our SPIRE server read access to AWS Parameter Store to read its config (we'll set this up later in the post)</li>
<li>Set permissions to allow for <a href="https://docs.aws.amazon.com/AmazonECS/latest/developerguide/ecs-exec.html">ECS Exec</a> as we'll be using this to run some SPIRE server commands.</li>
<li>Grant our SPIRE server the ability to update an AWS IAM Roles Anywhere trust anchor.</li>
</ol>
<pre class="z-code"><code><span class="z-text z-plain"># ECS Task policy for reading configuration
</span><span class="z-text z-plain">resource &quot;aws_iam_policy&quot; &quot;spire_server_policy&quot; {
</span><span class="z-text z-plain">  name        = &quot;spire-server-policy&quot;
</span><span class="z-text z-plain">  description = &quot;Allow reading from Secret Manager&quot;
</span><span class="z-text z-plain">
</span><span class="z-text z-plain">  policy = jsonencode({
</span><span class="z-text z-plain">    Version = &quot;2012-10-17&quot;
</span><span class="z-text z-plain">    Statement = [
</span><span class="z-text z-plain">      {
</span><span class="z-text z-plain">        Action = [
</span><span class="z-text z-plain">          &quot;ssm:GetParameter*&quot;,
</span><span class="z-text z-plain">        ]
</span><span class="z-text z-plain">        Effect   = &quot;Allow&quot;
</span><span class="z-text z-plain">        Resource = &quot;arn:aws:ssm:us-east-1:*:parameter/misaac-me/*&quot;
</span><span class="z-text z-plain">      },
</span><span class="z-text z-plain">      {
</span><span class="z-text z-plain">        &quot;Effect&quot; : &quot;Allow&quot;,
</span><span class="z-text z-plain">        &quot;Action&quot; : [
</span><span class="z-text z-plain">          &quot;ssmmessages:CreateControlChannel&quot;,
</span><span class="z-text z-plain">          &quot;ssmmessages:CreateDataChannel&quot;,
</span><span class="z-text z-plain">          &quot;ssmmessages:OpenControlChannel&quot;,
</span><span class="z-text z-plain">          &quot;ssmmessages:OpenDataChannel&quot;
</span><span class="z-text z-plain">        ],
</span><span class="z-text z-plain">        &quot;Resource&quot; : &quot;*&quot;
</span><span class="z-text z-plain">      },
</span><span class="z-text z-plain">      {
</span><span class="z-text z-plain">        &quot;Sid&quot; : &quot;IAMRolesAnywhere&quot;,
</span><span class="z-text z-plain">        &quot;Effect&quot; : &quot;Allow&quot;,
</span><span class="z-text z-plain">        &quot;Action&quot; : [
</span><span class="z-text z-plain">          &quot;rolesanywhere:UpdateTrustAnchor&quot;,
</span><span class="z-text z-plain">        ],
</span><span class="z-text z-plain">        &quot;Resource&quot; : &quot;*&quot;
</span><span class="z-text z-plain">      },
</span><span class="z-text z-plain">      {
</span><span class="z-text z-plain">        &quot;Sid&quot;: &quot;ReadSpecificSecrets&quot;,
</span><span class="z-text z-plain">        &quot;Effect&quot;: &quot;Allow&quot;,
</span><span class="z-text z-plain">        &quot;Action&quot;: [
</span><span class="z-text z-plain">          &quot;secretsmanager:GetSecretValue&quot;,
</span><span class="z-text z-plain">          &quot;secretsmanager:DescribeSecret&quot;
</span><span class="z-text z-plain">        ],
</span><span class="z-text z-plain">        &quot;Resource&quot;: [
</span><span class="z-text z-plain">            aws_secretsmanager_secret.upstream_authority_cert_file.arn,
</span><span class="z-text z-plain">            aws_secretsmanager_secret.upstream_authority_key_file.arn,
</span><span class="z-text z-plain">          ]
</span><span class="z-text z-plain">      }
</span><span class="z-text z-plain">
</span><span class="z-text z-plain">    ]
</span><span class="z-text z-plain">  })
</span><span class="z-text z-plain">}
</span><span class="z-text z-plain">
</span><span class="z-text z-plain"># Attach the Parameter Store policy to the task role
</span><span class="z-text z-plain">resource &quot;aws_iam_role_policy_attachment&quot; &quot;task_parameter_store&quot; {
</span><span class="z-text z-plain">  role       = aws_iam_role.ecs_task_role.name
</span><span class="z-text z-plain">  policy_arn = aws_iam_policy.parameter_store_read.arn
</span><span class="z-text z-plain">}
</span></code></pre>
<br>
<h4 id="the-spire-server-config"><a class="header-anchor no-hover-padding" href="#the-spire-server-config" aria-label="Anchor link for: the-spire-server-config"><span class="link-icon" aria-hidden="true"></span></a>
The SPIRE Server Config</h4>
<p>Before we setup the ECS Task definition that will run our SPIRE Server, we need to populate our SPIRE server configuration file. The SPIRE documentation provides a <a href="https://spiffe.io/docs/latest/deploying/spire_server/">handy reference</a> which goes into detail regarding all the knobs available. SPIRE is built to be readily extensible and has a thriving <a href="https://spiffe.io/docs/latest/planning/extending/">plugin ecosystem</a>.</p>
<p>We'll make use of a number of plugins below, and set up our config as a terraform template file, so we can interpolate our <code>UpstreamAuthority</code> and AWS IAM Roles Anywhere trust anchor. For our purposes, the following settings and plugins shall suffice:</p>
<pre class="z-code"><code><span class="z-text z-plain"># server.conf.tftpl
</span><span class="z-text z-plain">server {
</span><span class="z-text z-plain">    bind_address = &quot;0.0.0.0&quot;
</span><span class="z-text z-plain">    bind_port = &quot;8081&quot;
</span><span class="z-text z-plain">    socket_path = &quot;/tmp/spire-server/private/api.sock&quot;
</span><span class="z-text z-plain">    trust_domain = &quot;misaac.me&quot;
</span><span class="z-text z-plain">    data_dir = &quot;./.data&quot;
</span><span class="z-text z-plain">    log_level = &quot;DEBUG&quot;
</span><span class="z-text z-plain">    ca_key_type = &quot;rsa-2048&quot;
</span><span class="z-text z-plain">    ca_subject {
</span><span class="z-text z-plain">        country = [&quot;US&quot;]
</span><span class="z-text z-plain">        organization = [&quot;SPIRE&quot;]
</span><span class="z-text z-plain">        common_name = &quot;misaacspireissued&quot;
</span><span class="z-text z-plain">    }
</span><span class="z-text z-plain">}
</span><span class="z-text z-plain">
</span><span class="z-text z-plain">plugins {
</span><span class="z-text z-plain">    DataStore &quot;sql&quot; {
</span><span class="z-text z-plain">        plugin_data {
</span><span class="z-text z-plain">            database_type = &quot;sqlite3&quot;
</span><span class="z-text z-plain">            connection_string = &quot;./.data/datastore.sqlite3&quot;
</span><span class="z-text z-plain">        }
</span><span class="z-text z-plain">    }
</span><span class="z-text z-plain">
</span><span class="z-text z-plain">    NodeAttestor &quot;join_token&quot; {
</span><span class="z-text z-plain">        plugin_data {
</span><span class="z-text z-plain">        }
</span><span class="z-text z-plain">    }
</span><span class="z-text z-plain">
</span><span class="z-text z-plain">    KeyManager &quot;disk&quot; {
</span><span class="z-text z-plain">        plugin_data {
</span><span class="z-text z-plain">            keys_path = &quot;/tmp/spire-server/private/keys.json&quot;
</span><span class="z-text z-plain">        }
</span><span class="z-text z-plain">    }
</span><span class="z-text z-plain">
</span><span class="z-text z-plain">    UpstreamAuthority &quot;awssecret&quot; {
</span><span class="z-text z-plain">        plugin_data {
</span><span class="z-text z-plain">            region = &quot;us-east-1&quot;,
</span><span class="z-text z-plain">            # Use template variables for ARNs
</span><span class="z-text z-plain">            cert_file_arn = &quot;${cert_arn}&quot;,
</span><span class="z-text z-plain">            key_file_arn = &quot;${key_arn}&quot;        }
</span><span class="z-text z-plain">    }
</span><span class="z-text z-plain">
</span><span class="z-text z-plain">    BundlePublisher &quot;aws_rolesanywhere_trustanchor&quot; {
</span><span class="z-text z-plain">    plugin_data {
</span><span class="z-text z-plain">        region = &quot;us-east-1&quot;
</span><span class="z-text z-plain">        trust_anchor_id = &quot;${trust_anchor_id}&quot;
</span><span class="z-text z-plain">    }
</span><span class="z-text z-plain">}
</span><span class="z-text z-plain">}
</span><span class="z-text z-plain">
</span><span class="z-text z-plain">health_checks {
</span><span class="z-text z-plain">    listener_enabled = true
</span><span class="z-text z-plain">    bind_address = &quot;0.0.0.0&quot;
</span><span class="z-text z-plain">    # bind_port = &quot;80&quot; # Default is 80, uncomment if needed
</span><span class="z-text z-plain">}
</span></code></pre>
<p>We store this config file as an AWS SSM Parameter and we'll load in into a volume attached to our SPIRE server during our ECS task startup.</p>
<pre class="z-code"><code><span class="z-text z-plain">resource &quot;aws_ssm_parameter&quot; &quot;server_config&quot; {
</span><span class="z-text z-plain">  name        = &quot;/misaac-me/server-config&quot;
</span><span class="z-text z-plain">  description = &quot;SPIRE server configuration for misaac.me&quot;
</span><span class="z-text z-plain">  type        = &quot;SecureString&quot;
</span><span class="z-text z-plain">  value = templatefile(&quot;${path.module}/server.conf.tftpl&quot;, {
</span><span class="z-text z-plain">    cert_arn = aws_secretsmanager_secret.upstream_authority_cert_file.arn
</span><span class="z-text z-plain">    key_arn  = aws_secretsmanager_secret.upstream_authority_key_file.arn
</span><span class="z-text z-plain">    trust_anchor_id = aws_rolesanywhere_trust_anchor.iamra.id
</span><span class="z-text z-plain">  })
</span><span class="z-text z-plain">
</span><span class="z-text z-plain">}
</span></code></pre>
<p>Its worth pointing out a few technical choices made. One is to set <code>ca_key_type</code> to 2048. This ensures that the keys we're issued are compatible with the largest swath of AWS services we'd like to integrate in the future. For example, AWS Client VPN endpoints <a href="https://docs.aws.amazon.com/vpn/latest/clientvpn-admin/mutual.html">only</a> support 1024-bit and 2048-bit RSA key sizes.</p>
<p>Another is the choice of sql lite as our data store. In a production environment, you'd certainly want to use a managed database via the <a href="https://github.com/spiffe/spire/blob/v1.12.0/doc/plugin_server_datastore_sql.md"><code>sql</code></a> plugin.</p>
<p>Similarly, we use the disk <code>KeyManager</code> which means a set of private keys are persisted to disk. In a production enviroment, you'd also want to switch over to using the <a href="https://github.com/spiffe/spire/blob/v1.12.0/doc/plugin_server_keymanager_aws_kms.md"><code>aws_kms</code></a> key manager plugin instead which ensures your private key never leaves KMS.</p>
<br>
<h4 id="the-spire-server-ecs-task-definition"><a class="header-anchor no-hover-padding" href="#the-spire-server-ecs-task-definition" aria-label="Anchor link for: the-spire-server-ecs-task-definition"><span class="link-icon" aria-hidden="true"></span></a>
The SPIRE Server ECS Task Definition</h4>
<p>As mentioned earlier, we will need to provide the SPIRE server the config file. We create a shared config volume where we will place the config and attach both our init container and the SPIRE server container to it. We use the <a href="https://hub.docker.com/r/amazon/aws-cli">aws-cli</a> docker image as our init container's image and instruct it to fetch the SPIRE server config and save it to the volume. When starting the SPIRE server up, we pass it the location of the config file, so it can initialize properly.</p>
<pre class="z-code"><code><span class="z-text z-plain">resource &quot;aws_ecs_task_definition&quot; &quot;spire&quot; {
</span><span class="z-text z-plain">  family                   = &quot;misaac-me-spire&quot;
</span><span class="z-text z-plain">  requires_compatibilities = [&quot;FARGATE&quot;]
</span><span class="z-text z-plain">  network_mode             = &quot;awsvpc&quot;
</span><span class="z-text z-plain">  cpu                      = 256
</span><span class="z-text z-plain">  memory                   = 512
</span><span class="z-text z-plain">  execution_role_arn       = aws_iam_role.ecs_execution_role.arn
</span><span class="z-text z-plain">  task_role_arn            = aws_iam_role.ecs_task_role.arn
</span><span class="z-text z-plain">
</span><span class="z-text z-plain">  # Add volume for sharing configuration between containers
</span><span class="z-text z-plain">  volume {
</span><span class="z-text z-plain">    name = &quot;config-volume&quot;
</span><span class="z-text z-plain">  }
</span><span class="z-text z-plain">
</span><span class="z-text z-plain">  container_definitions = jsonencode([
</span><span class="z-text z-plain">    {
</span><span class="z-text z-plain">      name       = &quot;config-init&quot;
</span><span class="z-text z-plain">      image      = &quot;amazon/aws-cli:latest&quot;
</span><span class="z-text z-plain">      essential  = false
</span><span class="z-text z-plain">      entryPoint = [&quot;sh&quot;, &quot;-c&quot;]
</span><span class="z-text z-plain">
</span><span class="z-text z-plain">      command = [
</span><span class="z-text z-plain">        &lt;&lt;-EOF
</span><span class="z-text z-plain">          set -e
</span><span class="z-text z-plain">          echo &quot;Ensuring target directory exists on volume...&quot;
</span><span class="z-text z-plain">          mkdir -p /opt/spire/conf/server
</span><span class="z-text z-plain">
</span><span class="z-text z-plain">          echo &quot;Fetching SPIRE server config...&quot;
</span><span class="z-text z-plain">          aws ssm get-parameter --name &quot;/misaac-me/server-config&quot; --with-decryption --query &quot;Parameter.Value&quot; --output text &gt; /opt/spire/conf/server/server.conf
</span><span class="z-text z-plain">
</span><span class="z-text z-plain">          echo &quot;All configuration files fetched successfully to the shared volume.&quot;
</span><span class="z-text z-plain">        EOF
</span><span class="z-text z-plain">      ]
</span><span class="z-text z-plain">
</span><span class="z-text z-plain">
</span><span class="z-text z-plain">      logConfiguration = {
</span><span class="z-text z-plain">        logDriver = &quot;awslogs&quot;
</span><span class="z-text z-plain">        options = {
</span><span class="z-text z-plain">          &quot;awslogs-group&quot;         = aws_cloudwatch_log_group.spire.name
</span><span class="z-text z-plain">          &quot;awslogs-region&quot;        = &quot;us-east-1&quot;
</span><span class="z-text z-plain">          &quot;awslogs-stream-prefix&quot; = &quot;config-init&quot;
</span><span class="z-text z-plain">        }
</span><span class="z-text z-plain">      }
</span><span class="z-text z-plain">
</span><span class="z-text z-plain">      mountPoints = [
</span><span class="z-text z-plain">        {
</span><span class="z-text z-plain">          sourceVolume  = &quot;config-volume&quot;
</span><span class="z-text z-plain">          containerPath = &quot;/opt/spire/conf/server&quot;
</span><span class="z-text z-plain">          readOnly      = false
</span><span class="z-text z-plain">        }
</span><span class="z-text z-plain">      ]
</span><span class="z-text z-plain">    },
</span><span class="z-text z-plain">    {
</span><span class="z-text z-plain">      name      = &quot;app&quot;
</span><span class="z-text z-plain">      image     = &quot;ghcr.io/spiffe/spire-server:nightly&quot;
</span><span class="z-text z-plain">      essential = true
</span><span class="z-text z-plain">      dependsOn = [
</span><span class="z-text z-plain">        {
</span><span class="z-text z-plain">          containerName = &quot;config-init&quot;
</span><span class="z-text z-plain">          condition     = &quot;SUCCESS&quot;
</span><span class="z-text z-plain">        }
</span><span class="z-text z-plain">      ]
</span><span class="z-text z-plain">
</span><span class="z-text z-plain">      # Command to run SPIRE server with our config
</span><span class="z-text z-plain">      command = [
</span><span class="z-text z-plain">        &quot;sh&quot;,
</span><span class="z-text z-plain">        &quot;-c&quot;,
</span><span class="z-text z-plain">        &quot;mkdir -p /tmp/spire-server/private &amp;&amp; chmod 777 /tmp/spire-server/private &amp;&amp; spire-server run --config /opt/spire/conf/server/server.conf&quot;
</span><span class="z-text z-plain">      ]
</span><span class="z-text z-plain">
</span><span class="z-text z-plain">      environment = [
</span><span class="z-text z-plain">
</span><span class="z-text z-plain">      ]
</span><span class="z-text z-plain">      user = &quot;0&quot;
</span><span class="z-text z-plain">      linuxParameters = {
</span><span class="z-text z-plain">        initProcessEnabled = true
</span><span class="z-text z-plain">      }
</span><span class="z-text z-plain">
</span><span class="z-text z-plain">      portMappings = [
</span><span class="z-text z-plain">        {
</span><span class="z-text z-plain">          # Update port mapping to use SPIRE server port from config
</span><span class="z-text z-plain">          containerPort = 8081
</span><span class="z-text z-plain">          hostPort      = 8081
</span><span class="z-text z-plain">          protocol      = &quot;tcp&quot;
</span><span class="z-text z-plain">        },
</span><span class="z-text z-plain">        {
</span><span class="z-text z-plain">          # Update port mapping to use SPIRE server port from config
</span><span class="z-text z-plain">          containerPort = 80
</span><span class="z-text z-plain">          hostPort      = 80,
</span><span class="z-text z-plain">          protocol      = &quot;tcp&quot;
</span><span class="z-text z-plain">        }
</span><span class="z-text z-plain">      ]
</span><span class="z-text z-plain">
</span><span class="z-text z-plain">      mountPoints = [
</span><span class="z-text z-plain">        {
</span><span class="z-text z-plain">          sourceVolume  = &quot;config-volume&quot;
</span><span class="z-text z-plain">          containerPath = &quot;/opt/spire/conf/server&quot;
</span><span class="z-text z-plain">          readOnly      = true
</span><span class="z-text z-plain">        },
</span><span class="z-text z-plain">        {
</span><span class="z-text z-plain">          sourceVolume  = &quot;config-volume&quot;
</span><span class="z-text z-plain">          containerPath = &quot;/tmp/spire-server/private&quot;
</span><span class="z-text z-plain">          readOnly      = false
</span><span class="z-text z-plain">        }
</span><span class="z-text z-plain">      ]
</span><span class="z-text z-plain">
</span><span class="z-text z-plain">      logConfiguration = {
</span><span class="z-text z-plain">        logDriver = &quot;awslogs&quot;
</span><span class="z-text z-plain">        options = {
</span><span class="z-text z-plain">          &quot;awslogs-group&quot;         = aws_cloudwatch_log_group.spire.name
</span><span class="z-text z-plain">          &quot;awslogs-region&quot;        = &quot;us-east-1&quot;
</span><span class="z-text z-plain">          &quot;awslogs-stream-prefix&quot; = &quot;spire&quot;
</span><span class="z-text z-plain">        }
</span><span class="z-text z-plain">      }
</span><span class="z-text z-plain">    }
</span><span class="z-text z-plain">    
</span><span class="z-text z-plain">  ])
</span><span class="z-text z-plain">
</span><span class="z-text z-plain">  depends_on = [aws_secretsmanager_secret.upstream_authority_cert_file, aws_secretsmanager_secret.upstream_authority_key_file, aws_secretsmanager_secret.upstream_authority_bundle_file]
</span><span class="z-text z-plain">}
</span></code></pre>
<br>
<h4 id="the-security-groups"><a class="header-anchor no-hover-padding" href="#the-security-groups" aria-label="Anchor link for: the-security-groups"><span class="link-icon" aria-hidden="true"></span></a>
The security groups</h4>
<p>We need to set up the rules for traffic flow. Below, we allow SPIRE traffic into the ALB, and allow traffic from the ALB to our ECS task. We also allow the usual 80 and 443 ports (these are useful if we decide to setup healtchecks in the future), as well as outbound traffic to anywhere.</p>
<pre class="z-code"><code><span class="z-text z-plain"># Security group for ALB
</span><span class="z-text z-plain">resource &quot;aws_security_group&quot; &quot;alb_sg&quot; {
</span><span class="z-text z-plain">  name        = &quot;alb-security-group&quot;
</span><span class="z-text z-plain">  description = &quot;Allow HTTP and HTTPS inbound traffic for ALB&quot;
</span><span class="z-text z-plain">  vpc_id      = aws_vpc.main.id
</span><span class="z-text z-plain">
</span><span class="z-text z-plain">  tags = {
</span><span class="z-text z-plain">    Name = &quot;alb-sg&quot;
</span><span class="z-text z-plain">  }
</span><span class="z-text z-plain">}
</span><span class="z-text z-plain">
</span><span class="z-text z-plain">resource &quot;aws_vpc_security_group_ingress_rule&quot; &quot;allow_spire&quot; {
</span><span class="z-text z-plain">  security_group_id = aws_security_group.alb_sg.id
</span><span class="z-text z-plain">  cidr_ipv4         = &quot;0.0.0.0/0&quot;
</span><span class="z-text z-plain">  from_port         = 8081
</span><span class="z-text z-plain">  ip_protocol       = &quot;tcp&quot;
</span><span class="z-text z-plain">  to_port           = 8081
</span><span class="z-text z-plain">}
</span><span class="z-text z-plain">
</span><span class="z-text z-plain">resource &quot;aws_vpc_security_group_ingress_rule&quot; &quot;allow_http&quot; {
</span><span class="z-text z-plain">  security_group_id = aws_security_group.alb_sg.id
</span><span class="z-text z-plain">  cidr_ipv4         = &quot;0.0.0.0/0&quot;
</span><span class="z-text z-plain">  from_port         = 80
</span><span class="z-text z-plain">  ip_protocol       = &quot;tcp&quot;
</span><span class="z-text z-plain">  to_port           = 80
</span><span class="z-text z-plain">}
</span><span class="z-text z-plain">
</span><span class="z-text z-plain">resource &quot;aws_vpc_security_group_ingress_rule&quot; &quot;allow_https&quot; {
</span><span class="z-text z-plain">  security_group_id = aws_security_group.alb_sg.id
</span><span class="z-text z-plain">  cidr_ipv4         = &quot;0.0.0.0/0&quot;
</span><span class="z-text z-plain">  from_port         = 443
</span><span class="z-text z-plain">  ip_protocol       = &quot;tcp&quot;
</span><span class="z-text z-plain">  to_port           = 443
</span><span class="z-text z-plain">}
</span><span class="z-text z-plain">
</span><span class="z-text z-plain">resource &quot;aws_vpc_security_group_egress_rule&quot; &quot;alb_allow_all_outbound&quot; {
</span><span class="z-text z-plain">  security_group_id = aws_security_group.alb_sg.id
</span><span class="z-text z-plain">  cidr_ipv4         = &quot;0.0.0.0/0&quot;
</span><span class="z-text z-plain">  ip_protocol       = &quot;-1&quot;
</span><span class="z-text z-plain">}
</span><span class="z-text z-plain">
</span><span class="z-text z-plain"># Security group for ECS tasks
</span><span class="z-text z-plain">resource &quot;aws_security_group&quot; &quot;ecs_tasks_sg&quot; {
</span><span class="z-text z-plain">  name        = &quot;ecs-tasks-security-group&quot;
</span><span class="z-text z-plain">  description = &quot;Allow inbound traffic from ALB to ECS tasks&quot;
</span><span class="z-text z-plain">  vpc_id      = aws_vpc.main.id
</span><span class="z-text z-plain">
</span><span class="z-text z-plain">  tags = {
</span><span class="z-text z-plain">    Name = &quot;ecs-tasks-sg&quot;
</span><span class="z-text z-plain">  }
</span><span class="z-text z-plain">}
</span><span class="z-text z-plain">
</span><span class="z-text z-plain">resource &quot;aws_vpc_security_group_ingress_rule&quot; &quot;allow_alb_to_ecs&quot; {
</span><span class="z-text z-plain">  security_group_id            = aws_security_group.ecs_tasks_sg.id
</span><span class="z-text z-plain">  referenced_security_group_id = aws_security_group.alb_sg.id
</span><span class="z-text z-plain">  from_port                    = 8081
</span><span class="z-text z-plain">  ip_protocol                  = &quot;tcp&quot;
</span><span class="z-text z-plain">  to_port                      = 8081
</span><span class="z-text z-plain">}
</span><span class="z-text z-plain">
</span><span class="z-text z-plain">resource &quot;aws_vpc_security_group_egress_rule&quot; &quot;ecs_allow_all_outbound&quot; {
</span><span class="z-text z-plain">  security_group_id = aws_security_group.ecs_tasks_sg.id
</span><span class="z-text z-plain">  cidr_ipv4         = &quot;0.0.0.0/0&quot;
</span><span class="z-text z-plain">  ip_protocol       = &quot;-1&quot;
</span><span class="z-text z-plain">}
</span></code></pre>
<br>
<h4 id="the-ecs-service"><a class="header-anchor no-hover-padding" href="#the-ecs-service" aria-label="Anchor link for: the-ecs-service"><span class="link-icon" aria-hidden="true"></span></a>
The ECS Service</h4>
<p>We place our service in our private subnets, and assign it the ecs security group we created above. The other key thing here is that we reference the target group, <code>spire_ip</code> which we created earlier in the <a href="https://misaac.me/blog/grant-aws-access-to-codespaces-via-spiffe-spire-iam-roles-anywhere/#setting-up-route53-and-the-network-load-balancer">route 53/load balancer</a> section. This tells ECS to wire the task up to that listener once it is ready to receive requests. We also set up our terraform to redeploy this service anytime we run a new apply with a redeployment trigger. This is optional but proved utterly useful while iterating on this.</p>
<pre class="z-code"><code><span class="z-text z-plain">resource &quot;aws_ecs_service&quot; &quot;spire&quot; {
</span><span class="z-text z-plain">  name                   = &quot;misaac-me-spire&quot;
</span><span class="z-text z-plain">  cluster                = module.ecs.cluster_id
</span><span class="z-text z-plain">  task_definition        = aws_ecs_task_definition.spire.arn
</span><span class="z-text z-plain">  desired_count          = 1
</span><span class="z-text z-plain">  launch_type            = &quot;FARGATE&quot;
</span><span class="z-text z-plain">  enable_execute_command = true
</span><span class="z-text z-plain">
</span><span class="z-text z-plain">  network_configuration {
</span><span class="z-text z-plain">    subnets         = [aws_subnet.subnet_a.id, aws_subnet.subnet_b.id]
</span><span class="z-text z-plain">    security_groups = [aws_security_group.ecs_tasks_sg.id]
</span><span class="z-text z-plain">  }
</span><span class="z-text z-plain">
</span><span class="z-text z-plain">  load_balancer {
</span><span class="z-text z-plain">    target_group_arn = module.alb.target_groups[&quot;spire_ip&quot;].arn
</span><span class="z-text z-plain">    container_name   = &quot;app&quot;
</span><span class="z-text z-plain">    container_port   = 8081
</span><span class="z-text z-plain">  }
</span><span class="z-text z-plain">
</span><span class="z-text z-plain">  depends_on = [module.alb]
</span><span class="z-text z-plain">
</span><span class="z-text z-plain">  force_new_deployment = true
</span><span class="z-text z-plain">
</span><span class="z-text z-plain">  triggers = {
</span><span class="z-text z-plain">    redeployment = plantimestamp()
</span><span class="z-text z-plain">  }
</span><span class="z-text z-plain">}
</span></code></pre>
<br>
<h3 id="verifiying-the-deployment"><a class="header-anchor no-hover-padding" href="#verifiying-the-deployment" aria-label="Anchor link for: verifiying-the-deployment"><span class="link-icon" aria-hidden="true"></span></a>
Verifiying the deployment</h3>
<p>After hitting <code>terraform plan</code> and <code>terraform apply</code>, head over to your the ECS page on AWS and drill down into the now running task. Select the logs tab to view the startup logs. Because we set the log level to <code>DEBUG</code> in our <a href="https://misaac.me/blog/grant-aws-access-to-codespaces-via-spiffe-spire-iam-roles-anywhere/#the-spire-server-config">server config</a>, you'll see detailed startup information as the SPIRE server tries to setup all the plugins we enabled.</p>
<p>The best way to be sure things are all good to go however is to run the health check command. For this and further interactions with the SPIRE server, we'll rely on the ECS Exec functionality that we enabled. Grab the ECS task ID and run the healtcheck command. You should see output similar to below.</p>
<pre class="z-code"><code><span class="z-text z-plain">
</span><span class="z-text z-plain">$ aws ecs execute-command --cluster misaac-me-cluster \
</span><span class="z-text z-plain">    --task 7a1c81dd127448f6aad9b9c8064efa54 \
</span><span class="z-text z-plain">    --container app \
</span><span class="z-text z-plain">    --interactive \
</span><span class="z-text z-plain">    --command &quot;/opt/spire/bin/spire-server healthcheck&quot;
</span><span class="z-text z-plain">
</span><span class="z-text z-plain">The Session Manager plugin was installed successfully. Use the AWS CLI to start a session.
</span><span class="z-text z-plain">
</span><span class="z-text z-plain">
</span><span class="z-text z-plain">Starting session with SessionId: ecs-execute-command-dztjl3tojo6pgpcv5be5vs42x8
</span><span class="z-text z-plain">Server is healthy.
</span><span class="z-text z-plain">
</span><span class="z-text z-plain">
</span><span class="z-text z-plain">Exiting session with sessionId: ecs-execute-command-dztjl3tojo6pgpcv5be5vs42x8.
</span></code></pre>
<p>The line <strong>Server is healthy</strong> indicates that we're good to go. At this point, we are ready to try to get an SVID. For this, we'll need to setup the SPIRE agent.</p>
<br>
<h2 id="setting-up-the-spire-agent"><a class="header-anchor no-hover-padding" href="#setting-up-the-spire-agent" aria-label="Anchor link for: setting-up-the-spire-agent"><span class="link-icon" aria-hidden="true"></span></a>
Setting up the SPIRE Agent</h2>
<p>Follow the instruction on <a href="https://spiffe.io/docs/latest/try/getting-started-linux-macos-x/">Quickstart for Linux and MacOSX</a> to install the SPIRE Agent on your device. If you're on Windows, you can find Windows binaries for SPIRE on the <a href="https://github.com/spiffe/spire/releases">GitHub Releases page</a>. The SPIRE team <a href="https://www.cncf.io/blog/2022/05/18/spire-now-runs-on-windows/">has worked hard</a> to ensure the user experience is consistent accross platforms so the rest of the instructions should work as described.</p>
<h3 id="the-agent-config"><a class="header-anchor no-hover-padding" href="#the-agent-config" aria-label="Anchor link for: the-agent-config"><span class="link-icon" aria-hidden="true"></span></a>
The Agent Config</h3>
<p>Just like the server, the SPIRE agent needs a config file to tell it how to run. Here's an example where we provide the SPIRE server address the agent should use, as well as set it up to attest using a join token. The SPIRE agent expects this config to be located at <code>./conf/agent/agent.conf</code>.</p>
<p>Another production note is that below, we set the <code>insecure_bootstrap</code> flag. Insecure bootstrap is <strong>NOT</strong> appropriate for production use. We only use it here to make things slightly easier as we evaluate. To turn this off and connect the ideal way remove the <code>insecure_bootstrap</code> line, provide your agent with the CA trust bundle, placing it in the same location as the config file, and uncomment the <code>trust_bundle_path</code> line. With the bundle, the SPIRE agent will verify the server chain, rather than perform just the soft verification of the server URI.</p>
<pre class="z-code"><code><span class="z-text z-plain">agent {
</span><span class="z-text z-plain">    data_dir = &quot;./.data&quot;
</span><span class="z-text z-plain">    log_level = &quot;DEBUG&quot;
</span><span class="z-text z-plain">    server_address = &quot;spire.misaac.me&quot;
</span><span class="z-text z-plain">    server_port = &quot;8081&quot;
</span><span class="z-text z-plain">    socket_path =&quot;/tmp/spire-agent/public/api.sock&quot;
</span><span class="z-text z-plain">    # trust_bundle_path = &quot;./conf/agent/dummy_root_ca.crt&quot;
</span><span class="z-text z-plain">    trust_domain = &quot;misaac.me&quot;
</span><span class="z-text z-plain">    insecure_bootstrap = true
</span><span class="z-text z-plain">}
</span><span class="z-text z-plain">
</span><span class="z-text z-plain">plugins {
</span><span class="z-text z-plain">    NodeAttestor &quot;join_token&quot; {
</span><span class="z-text z-plain">        plugin_data {
</span><span class="z-text z-plain">        }
</span><span class="z-text z-plain">    }
</span><span class="z-text z-plain">    KeyManager &quot;disk&quot; {
</span><span class="z-text z-plain">        plugin_data {
</span><span class="z-text z-plain">            directory = &quot;./.data&quot;
</span><span class="z-text z-plain">        }
</span><span class="z-text z-plain">    }
</span><span class="z-text z-plain">    WorkloadAttestor &quot;unix&quot; {
</span><span class="z-text z-plain">        plugin_data {
</span><span class="z-text z-plain">        }
</span><span class="z-text z-plain">    }
</span><span class="z-text z-plain">}
</span></code></pre>
<br>
<h3 id="node-attestation-with-a-join-token"><a class="header-anchor no-hover-padding" href="#node-attestation-with-a-join-token" aria-label="Anchor link for: node-attestation-with-a-join-token"><span class="link-icon" aria-hidden="true"></span></a>
Node Attestation with a join token</h3>
<p>With your agent installed, and your agent config all set up, our next step is to request a <a href="https://spiffe.io/docs/latest/deploying/configuring/#join-token">join token</a> from the SPIRE server. This will allow us to prove our agents identity to the SPIRE server, a process known as <a href="https://spiffe.io/docs/latest/spire-about/spire-concepts/#node-attestation">Node Attestation</a>. Note that for your workloads running on cloud compute, you should prefer any of the other <code>NodeAttestor</code> <a href="https://spiffe.io/docs/latest/deploying/spire_agent/#built-in-plugins">plugins</a> which use things like AWS instance identity or Kubernetes service tokens.</p>
<p>You may be wondering, "hey, you told me that <a href="https://misaac.me/blog/grant-aws-access-to-codespaces-via-spiffe-spire-iam-roles-anywhere/#preamble">no secrets</a> are required!" And you're right to wonder - a join token does technically function as a secret during the initial bootstrapping of the SPIRE Agent.</p>
<p>Note however, that our argument was that the <strong>workload</strong> does not need to hold a secret. Remember, that with a traditional secret such as an API key, database password, TLS private key or other long-lived credential, the problem is in their lifecycle and distribution. They need to be provisioned <strong>to</strong> the workload <strong>before</strong> it can authenticate - which is what leads to the "secret zero problem" - how do you securely get that first secret to the workload?</p>
<p>Our join token however is <em><strong>not</strong></em> held by the workload. The <em>workload itself</em>, (i.e a specific application instance running in a pod or VM) does not possess this join token. Instead, the SPIRE Agent does, and only uses it for its <strong>initial</strong> authentication to the SPIRE server. Also, unlike most secrets, the join token expires immediately after use and is only used by the agent to perform node attestation.</p>
<p>The key takeway then is the shift in trust boundary. Instead of each individual workload needing a unique, pre-provisioned secret, you now have a controlled, temporary secret, (the join token), that is used <em>once</em> by the SPIRE agent to establish a secure channel to the SPIRE server. This shifts the "secret zero" problem from potentially thousands of workloads to a single, tightly controlled initial authentication for the SPIRE agent.</p>
<p>Here's the command to run, and the output to expect.</p>
<pre class="z-code"><code><span class="z-text z-plain">
</span><span class="z-text z-plain">$ aws ecs execute-command --cluster misaac-me-cluster \
</span><span class="z-text z-plain">    --task 7a1c81dd127448f6aad9b9c8064efa54 \
</span><span class="z-text z-plain">    --container app \
</span><span class="z-text z-plain">    --interactive \
</span><span class="z-text z-plain">    --command &quot;/opt/spire/bin/spire-server token generate -spiffeID spiffe://misaac.me/myagent&quot;
</span><span class="z-text z-plain">
</span><span class="z-text z-plain">The Session Manager plugin was installed successfully. Use the AWS CLI to start a session.
</span><span class="z-text z-plain">
</span><span class="z-text z-plain">
</span><span class="z-text z-plain">Starting session with SessionId: ecs-execute-command-gg5fgucsodxjrjz5netervpkce
</span><span class="z-text z-plain">Token: c31f79f2-3462-11f0-8be1-06e43f96721d
</span><span class="z-text z-plain">
</span><span class="z-text z-plain">
</span><span class="z-text z-plain">Exiting session with sessionId: ecs-execute-command-gg5fgucsodxjrjz5netervpkce.
</span><span class="z-text z-plain">
</span></code></pre>
<p>Armed with this join token, we can now perform node attestation. Run the spire agent run command, passing in the join token:</p>
<pre class="z-code"><code><span class="z-text z-plain">
</span><span class="z-text z-plain">$ ./bin/spire-agent run -joinToken c31f79f2-3462-11f0-8be1-06e43f96721d
</span><span class="z-text z-plain">WARN[0000] Current umask 0022 is too permissive; setting umask 0027 
</span><span class="z-text z-plain">INFO[0000] Starting agent                                data_dir=./.data version=1.12.0-dev-unk
</span><span class="z-text z-plain">INFO[0000] Plugin loaded                                 external=false plugin_name=join_token plugin_type=NodeAttestor subsystem_name=catalog
</span><span class="z-text z-plain">INFO[0000] Configured plugin                             external=false plugin_name=disk plugin_type=KeyManager reconfigurable=false subsystem_name=catalog
</span><span class="z-text z-plain">INFO[0000] Plugin loaded                                 external=false plugin_name=disk plugin_type=KeyManager subsystem_name=catalog
</span><span class="z-text z-plain">INFO[0000] Configured plugin                             external=false plugin_name=unix plugin_type=WorkloadAttestor reconfigurable=false subsystem_name=catalog
</span><span class="z-text z-plain">INFO[0000] Plugin loaded                                 external=false plugin_name=unix plugin_type=WorkloadAttestor subsystem_name=catalog
</span><span class="z-text z-plain">INFO[0000] Bundle is not found                           subsystem_name=attestor
</span><span class="z-text z-plain">DEBU[0000] No pre-existing agent SVID found. Will perform node attestation  subsystem_name=attestor
</span><span class="z-text z-plain">WARN[0000] Keys recovered, but no SVID found. Generating new keypair  subsystem_name=attestor
</span><span class="z-text z-plain">INFO[0000] SVID is not found. Starting node attestation  subsystem_name=attestor
</span><span class="z-text z-plain">WARN[0000] Insecure bootstrap enabled; skipping server certificate verification  subsystem_name=attestor
</span><span class="z-text z-plain">WARN[0000] Insecure bootstrap enabled; skipping server certificate verification  subsystem_name=attestor
</span><span class="z-text z-plain">INFO[0000] Node attestation was successful               reattestable=false spiffe_id=&quot;spiffe://misaac.me/spire/agent/join_token/c31f79f2-3462-11f0-8be1-06e43f96721d&quot; subsystem_name=attestor
</span><span class="z-text z-plain">DEBU[0000] Entry created                                 entry=b3be6f38-e411-4ff8-a872-3285c54d290a selectors_added=1 spiffe_id=&quot;spiffe://misaac.me/myagent&quot; subsystem_name=cache_manager
</span></code></pre>
<br>
<h3 id="creating-a-registration-entry"><a class="header-anchor no-hover-padding" href="#creating-a-registration-entry" aria-label="Anchor link for: creating-a-registration-entry"><span class="link-icon" aria-hidden="true"></span></a>
Creating a registration entry</h3>
<p>To allow SPIRE to identify a workload, you need to register it with the SPIRE Server using registration entries. These entries specify how SPIRE should recognize the workload and the corresponding SPIFFE ID it should be assigned. The set of properties by which SPIRE is to recognize a workload as valid are known as selectors.</p>
<p>The following command creates a registration entry based on the current user's UID (<code>$(id -u)</code>) — in other words, the UID is our only selector.  Open a new terminal window side-by-side with the one running the SPIRE agent and run the command below. You should see output similar to:</p>
<pre class="z-code"><code><span class="z-text z-plain">
</span><span class="z-text z-plain">$ aws ecs execute-command --cluster misaac-me-cluster \
</span><span class="z-text z-plain">    --task 7a1c81dd127448f6aad9b9c8064efa54 \
</span><span class="z-text z-plain">    --container app \
</span><span class="z-text z-plain">    --interactive \
</span><span class="z-text z-plain">    --command &quot;/opt/spire/bin/spire-server entry create -dns m.misaac.me -parentID spiffe://misaac.me/myagent \
</span><span class="z-text z-plain">    -spiffeID spiffe://misaac.me/myservice -selector unix:uid:501&quot;
</span><span class="z-text z-plain">
</span><span class="z-text z-plain">The Session Manager plugin was installed successfully. Use the AWS CLI to start a session.
</span><span class="z-text z-plain">
</span><span class="z-text z-plain">
</span><span class="z-text z-plain">Starting session with SessionId: ecs-execute-command-sgji2gulvqv9qnvxiuabrzztjy
</span><span class="z-text z-plain">Entry ID         : 0892eada-63ff-4d22-9762-2a348bdde7c7
</span><span class="z-text z-plain">SPIFFE ID        : spiffe://misaac.me/myservice
</span><span class="z-text z-plain">Parent ID        : spiffe://misaac.me/myagent
</span><span class="z-text z-plain">Revision         : 0
</span><span class="z-text z-plain">X509-SVID TTL    : default
</span><span class="z-text z-plain">JWT-SVID TTL     : default
</span><span class="z-text z-plain">Selector         : unix:uid:501
</span><span class="z-text z-plain">DNS name         : m.misaac.me
</span><span class="z-text z-plain">
</span><span class="z-text z-plain">
</span><span class="z-text z-plain">
</span><span class="z-text z-plain">Exiting session with sessionId: ecs-execute-command-sgji2gulvqv9qnvxiuabrzztjy.
</span><span class="z-text z-plain">
</span></code></pre>
<p>Over on the spire agent terminal, you should also see that the agent
<span id="informed-workload">got informed about this new workload</span>:</p>
<pre class="z-code"><code><span class="z-text z-plain">DEBU[0083] Entry created                                 entry=0892eada-63ff-4d22-9762-2a348bdde7c7 selectors_added=1 spiffe_id=&quot;spiffe://misaac.me/myservice&quot; subsystem_name=cache_manager
</span><span class="z-text z-plain">DEBU[0083] Renewing stale entries                        cache_type=workload count=1 limit=500 subsystem_name=manager
</span><span class="z-text z-plain">INFO[0083] Creating X509-SVID                            entry_id=0892eada-63ff-4d22-9762-2a348bdde7c7 spiffe_id=&quot;spiffe://misaac.me/myservice&quot; subsystem_name=manager
</span><span class="z-text z-plain">DEBU[0083] SVID updated                                  entry=0892eada-63ff-4d22-9762-2a348bdde7c7 spiffe_id=&quot;spiffe://misaac.me/myservice&quot; subsystem_name=cache_manager
</span></code></pre>
<p>It then updated its local store of workload entries, and created the SVID for the workload. This does not mean that the workload will receive this SVID, the receipt will only occur after the workload requests the SVID, and the agent successfully verifies it via workload attestation.</p>
<br>
<h2 id="requesting-a-spiffe-svid-a-k-a-certificate"><a class="header-anchor no-hover-padding" href="#requesting-a-spiffe-svid-a-k-a-certificate" aria-label="Anchor link for: requesting-a-spiffe-svid-a-k-a-certificate"><span class="link-icon" aria-hidden="true"></span></a>
Requesting a SPIFFE SVID, a.k.a certificate</h2>
<p>We are finally ready to request an SVID from our SPIRE agent. This is also when workload attestation will occur. Workload attestation asks the question "Who is this process and do I have an SVID for it?" To attest the workload, the SPIRE agent verifies the workload's identity by comparing its observed attributes against the registration entries.</p>
<p>In our case, we specified a UID of 501 as the selector when creating the registration entry and as you <a href="https://misaac.me/blog/grant-aws-access-to-codespaces-via-spiffe-spire-iam-roles-anywhere/#informed-workload">saw above</a>, the SPIRE server sent that information and the corresponding SVID down to the agent for caching. This means that we are trusting the environment itself to confirm the workloads identity.</p>
<p>We'll <span id="fetch">simulate</span> the act of a workload requesting an SVID by running <code>bin/spire-agent api fetch x509 -write /tmp/</code>. When this happens, our SPIRE agent will compare our calling process information to the registration entries it has cached, and then if everything checks out, return the correct SVID to us from its cache.</p>
<p>Here's what that would look like:</p>
<pre class="z-code"><code><span class="z-text z-plain">$ bin/spire-agent api fetch x509 -write /tmp/          
</span><span class="z-text z-plain">Received 1 svid after 254.053709ms
</span><span class="z-text z-plain">
</span><span class="z-text z-plain">SPIFFE ID:              spiffe://misaac.me/myservice
</span><span class="z-text z-plain">SVID Valid After:       2025-05-19 11:06:54 +0000 UTC
</span><span class="z-text z-plain">SVID Valid Until:       2025-05-19 12:07:04 +0000 UTC
</span><span class="z-text z-plain">Intermediate #1 Valid After:    2025-05-18 21:04:32 +0000 UTC
</span><span class="z-text z-plain">Intermediate #1 Valid Until:    2025-05-19 21:04:42 +0000 UTC
</span><span class="z-text z-plain">CA #1 Valid After:      2025-04-29 01:29:07 +0000 UTC
</span><span class="z-text z-plain">CA #1 Valid Until:      2035-04-27 01:29:07 +0000 UTC
</span><span class="z-text z-plain">
</span><span class="z-text z-plain">Writing SVID #0 to file /tmp/svid.0.pem.
</span><span class="z-text z-plain">Writing key #0 to file /tmp/svid.0.key.
</span><span class="z-text z-plain">Writing bundle #0 to file /tmp/bundle.0.pem.
</span><span class="z-text z-plain">
</span></code></pre>
<p>Using <code>openssl</code> shows us the contents of the SVID:</p>
<pre class="z-code"><code><span class="z-text z-plain">$ openssl x509 -in /tmp/svid.0.pem -text -noout
</span><span class="z-text z-plain">Certificate:
</span><span class="z-text z-plain">    Data:
</span><span class="z-text z-plain">        Version: 3 (0x2)
</span><span class="z-text z-plain">        Serial Number:
</span><span class="z-text z-plain">            56:fe:78:15:73:a6:7f:ce:c8:34:14:2a:23:eb:42:0a
</span><span class="z-text z-plain">        Signature Algorithm: sha256WithRSAEncryption
</span><span class="z-text z-plain">        Issuer: C=US, O=SPIRE, CN=misaacspireissued, serialNumber=110299478376811626996927807267782596616
</span><span class="z-text z-plain">        Validity
</span><span class="z-text z-plain">            Not Before: May 19 11:06:54 2025 GMT
</span><span class="z-text z-plain">            Not After : May 19 12:07:04 2025 GMT
</span><span class="z-text z-plain">        Subject: C=US, O=SPIRE, CN=m.misaac.me
</span><span class="z-text z-plain">        Subject Public Key Info:
</span><span class="z-text z-plain">            Public Key Algorithm: id-ecPublicKey
</span><span class="z-text z-plain">                Public-Key: (256 bit)
</span><span class="z-text z-plain">                pub:
</span><span class="z-text z-plain">                    04:ca:48:c7:a6:c3:70:bd:36:cd:bb:61:d5:f0:cb:
</span><span class="z-text z-plain">                    fe:ed:6c:10:e5:a8:50:ac:1b:6c:72:77:68:ab:12:
</span><span class="z-text z-plain">                    bd:3b:b5:0b:4c:ee:b0:06:ea:2f:54:70:54:66:2c:
</span><span class="z-text z-plain">                    0b:b5:a3:b8:7f:08:b7:3a:1c:c3:cc:7c:65:02:64:
</span><span class="z-text z-plain">                    cb:aa:90:68:f2
</span><span class="z-text z-plain">                ASN1 OID: prime256v1
</span><span class="z-text z-plain">                NIST CURVE: P-256
</span><span class="z-text z-plain">        X509v3 extensions:
</span><span class="z-text z-plain">            X509v3 Key Usage: critical
</span><span class="z-text z-plain">                Digital Signature, Key Encipherment, Key Agreement
</span><span class="z-text z-plain">            X509v3 Extended Key Usage: 
</span><span class="z-text z-plain">                TLS Web Server Authentication, TLS Web Client Authentication
</span><span class="z-text z-plain">            X509v3 Basic Constraints: critical
</span><span class="z-text z-plain">                CA:FALSE
</span><span class="z-text z-plain">            X509v3 Subject Key Identifier: 
</span><span class="z-text z-plain">                0D:76:40:09:70:2D:1F:DA:95:AD:CF:8A:37:21:F3:87:43:BE:80:0E
</span><span class="z-text z-plain">            X509v3 Authority Key Identifier: 
</span><span class="z-text z-plain">                6D:88:0B:FF:20:6C:AA:0E:E5:FB:CF:21:0A:A2:D5:16:33:55:77:3A
</span><span class="z-text z-plain">            X509v3 Subject Alternative Name: 
</span><span class="z-text z-plain">                DNS:m.misaac.me, URI:spiffe://misaac.me/myservice
</span><span class="z-text z-plain">    Signature Algorithm: sha256WithRSAEncryption
</span><span class="z-text z-plain">    Signature Value:
</span><span class="z-text z-plain">        84:d2:b6:e6:d1:b0:3d:b3:a5:33:4e:23:f5:55:ec:3f:7f:7b:
</span><span class="z-text z-plain">        9c:5e:18:b3:db:ce:cc:f7:aa:e3:27:18:b6:4e:cf:65:06:05:
</span><span class="z-text z-plain">        71:6d:48:43:fe:66:24:91:49:80:c5:b0:5d:6e:c0:0f:92:32:
</span><span class="z-text z-plain">        0f:a8:4c:f8:5b:18:20:1e:8d:bb:e9:80:a3:74:50:42:95:a9:
</span><span class="z-text z-plain">        e9:2f:e1:59:7d:7f:48:03:04:94:58:e0:87:de:25:7a:d2:d1:
</span><span class="z-text z-plain">        b1:f0:9d:d5:e1:b7:44:51:64:a5:e8:ef:9e:5e:47:59:ae:da:
</span><span class="z-text z-plain">        44:ba:0b:9e:4c:68:9f:1f:38:3e:fe:00:af:47:a2:8d:69:fd:
</span><span class="z-text z-plain">        29:50:26:fe:4c:65:5e:0e:ba:ac:10:34:18:8b:e0:d1:54:8d:
</span><span class="z-text z-plain">        8e:24:73:0d:db:5f:a3:81:2d:a3:46:a3:c1:ef:96:86:ba:92:
</span><span class="z-text z-plain">        d8:e5:d3:1b:a4:a4:e2:f8:cf:2b:3c:ba:80:0e:24:ff:5b:db:
</span><span class="z-text z-plain">        ef:79:1a:40:65:e1:df:60:6c:4c:f6:f5:b0:06:9e:82:0b:88:
</span><span class="z-text z-plain">        6c:2d:b4:f9:c5:a6:c5:5b:89:be:a9:4d:eb:32:a7:b3:3c:4f:
</span><span class="z-text z-plain">        33:da:76:d5:18:93:b6:62:d6:e4:97:7a:24:6f:77:c0:01:c8:
</span><span class="z-text z-plain">        45:0c:1e:bd:ac:85:33:ce:30:e8:a2:05:93:5d:88:5d:40:21:
</span><span class="z-text z-plain">        2b:0d:aa:bf
</span><span class="z-text z-plain">
</span></code></pre>
<p>Notice the short duration of the SVID. Although the short SVID duration might seem alarming, the SPIRE agent handles renewals automatically. This design choice is a security feature. By forcing frequent re-attestation, SPIRE continuously verifies the workload's identity (e.g., the uid remains 501) and its registration status (the SVID is still valid) before issuing a new, short-lived SVID.</p>
<p>That said, your workload now needs to grapple with tracking the SVID expiration and continually requesting renewals. Does this mean you have to go re-architect your legacy apps? Fortunately no, the <a href="https://github.com/spiffe/spiffe-helper">spiffe-helper</a> project is designed to help you solve this problem without code changes. The handy utility takes care of fetching X.509 SVID certificates from the SPIFFE agent, launching a process to use them, and automatically renewing and reloading certificates as needed.</p>
<p>We cover this process <a href="http://misaac.me/blog/automated-aws-credential-renewal-spiffe-helper-roles-anywhere/">here</a>, but for now, we don't have to worry about this at the moment as we'll be using our SVID only once, so let's go authenticate to AWS!</p>
<br>
<h2 id="use-a-spiffe-svid-to-obtain-aws-credentials-via-iam-roles-anywhere"><a class="header-anchor no-hover-padding" href="#use-a-spiffe-svid-to-obtain-aws-credentials-via-iam-roles-anywhere" aria-label="Anchor link for: use-a-spiffe-svid-to-obtain-aws-credentials-via-iam-roles-anywhere"><span class="link-icon" aria-hidden="true"></span></a>
Use a SPIFFE SVID to obtain AWS credentials via IAM Roles Anywhere</h2>
<p>To obtain temporary credentials using IAM Roles Anywhere, you need all of the following:</p>
<ul>
<li>
<p>A Profile configured in IAM Roles Anywhere</p>
</li>
<li>
<p>A Role ARN from IAM</p>
</li>
<li>
<p>A trust anchor configured in IAM Roles Anywhere</p>
</li>
<li>
<p>An end-entity certificate from your certificate authority</p>
</li>
<li>
<p>The certificate associated private key is required in most cases, except when inferred. For example when using OS certificate stores.</p>
</li>
<li>
<p>The credential helper tool provided by AWS</p>
</li>
</ul>
<p>We setup the first three in <a href="https://misaac.me/blog/grant-aws-access-to-codespaces-via-spiffe-spire-iam-roles-anywhere/#setting-up-iam-roles-anywhere">setting up iam roles anywhere</a> and we just obtained our end-entity certificate along with its private key.</p>
<p>To get the credential helper, head over to the <a href="https://github.com/aws/rolesanywhere-credential-helper">rolesanywhere-credential-helper</a> GitHub repository and follow the instructions to build your binary. Alternatively, you could use the Download links on the AWS documentation page <a href="https://docs.aws.amazon.com/rolesanywhere/latest/userguide/credential-helper.html">here</a>.</p>
<p>Once you have the binary built or downloaded, if you're on a unix or unix-like OS, you might need to <code>chmod+x</code> it so that you can execute it. Verify that you can run it with <code>./aws_signing_helper -h</code>. You should see:</p>
<pre class="z-code"><code><span class="z-text z-plain">$ ./aws_signing_helper -h
</span><span class="z-text z-plain">A tool that utilizes certificates and their associated private keys to 
</span><span class="z-text z-plain">sign requests to AWS IAM Roles Anywhere&#39;s CreateSession API and retrieve temporary 
</span><span class="z-text z-plain">AWS security credentials. This tool exposes multiple commands to make credential 
</span><span class="z-text z-plain">retrieval and rotation more convenient.
</span><span class="z-text z-plain">
</span><span class="z-text z-plain">Usage:
</span><span class="z-text z-plain">  aws_signing_helper [command] [flags]
</span><span class="z-text z-plain">  aws_signing_helper [command]
</span><span class="z-text z-plain">
</span><span class="z-text z-plain">Available Commands:
</span><span class="z-text z-plain">  completion            Generate the autocompletion script for the specified shell
</span><span class="z-text z-plain">  credential-process    Retrieve AWS credentials in the appropriate format for external credential processes
</span><span class="z-text z-plain">  help                  Help about any command
</span><span class="z-text z-plain">  read-certificate-data Diagnostic command to read certificate data
</span><span class="z-text z-plain">  serve                 Serve AWS credentials through a local endpoint
</span><span class="z-text z-plain">  sign-string           Signs a fixed string using the passed-in private key (or reference to private key)
</span><span class="z-text z-plain">  update                Updates a profile in the AWS credentials file with new AWS credentials
</span><span class="z-text z-plain">  version               Prints the version number of the credential helper
</span><span class="z-text z-plain">
</span><span class="z-text z-plain">Flags:
</span><span class="z-text z-plain">  -h, --help   help for aws_signing_helper
</span><span class="z-text z-plain">
</span><span class="z-text z-plain">Use &quot;aws_signing_helper [command] --help&quot; for more information about a command.
</span></code></pre>
<p>Before we use the <code>aws_signing_helper</code> to request our certificate, there's one more thing we need to do. The SPIRE agent does not include SPIRE's intermediate CA in the bundle it issues when we ran <a href="https://misaac.me/blog/grant-aws-access-to-codespaces-via-spiffe-spire-iam-roles-anywhere/#fetch">fetch</a>. Instead, it places that in the end-entity certificate stored in <code>/tmp/svid.0.pem</code>. So we'll use a one-liner to copy that into the bundle.</p>
<pre class="z-code"><code><span class="z-text z-plain">echo -e &quot;\n$(awk &#39;/-----BEGIN CERTIFICATE-----/{i++}i==2{print}&#39; /tmp/svid.0.pem)&quot; &gt;&gt; /tmp/bundle.0.pem
</span></code></pre>
<p>With our bundle ready, we can now call <code>aws_signing_helper</code> and request an AWS credential.</p>
<pre class="z-code"><code><span class="z-text z-plain">$ eval $(./aws_signing_helper credential-process \
</span><span class="z-text z-plain">      --certificate /tmp/svid.0.pem \
</span><span class="z-text z-plain">      --private-key /tmp/svid.0.key \
</span><span class="z-text z-plain">      --intermediates /tmp/bundle.0.pem \
</span><span class="z-text z-plain">      --trust-anchor-arn arn:aws:rolesanywhere:us-east-1:012345678901:trust-anchor/9f455be1-f25f-495b-9e99-f6a630d62cbb \
</span><span class="z-text z-plain">      --profile-arn arn:aws:rolesanywhere:us-east-1:012345678901:profile/737869f1-ffd0-4674-ac2b-f3d6895b4499 \
</span><span class="z-text z-plain">      --role-arn arn:aws:iam::012345678901:role/test | jq -r &#39;with_entries(select(.key | match(&quot;^(AccessKeyId|SecretAccessKey|SessionToken)$&quot;))) | &quot;export AWS_ACCESS_KEY_ID=\(.AccessKeyId)\nexport AWS_SECRET_ACCESS_KEY=\(.SecretAccessKey)\nexport AWS_SESSION_TOKEN=\(.SessionToken)&quot;&#39;)
</span></code></pre>
<p>Now that we have our credentials, let's do something with it, let's run <code>whoami</code>.</p>
<pre class="z-code"><code><span class="z-text z-plain">$ aws sts get-caller-identity
</span><span class="z-text z-plain">{
</span><span class="z-text z-plain">    &quot;UserId&quot;: &quot;AROADBQP57FF2AEXAMPLE:30a7fe7d714958787f6075c9904ce642&quot;,
</span><span class="z-text z-plain">    &quot;Account&quot;: &quot;012345678901&quot;,
</span><span class="z-text z-plain">    &quot;Arn&quot;: &quot;arn:aws:sts::012345678901:assumed-role/test/30a7fe7d714958787f6075c9904ce642&quot;
</span><span class="z-text z-plain">}
</span><span class="z-text z-plain">
</span></code></pre>
<p>And there we have it - we've obtained AWS access using an SVID issued by SPIRE. In our next article, we'll use the same SVID to connect to AWS VPN.</p>

        </section>

        
                
                
                    
                        
                        
                        
                    
                    
                        
                        
                        
                    
                
                
            <nav class="full-width article-navigation">
                <div><a href="https://misaac.me/blog/connecting-github-codespaces-to-aws-vpn-via-spiffe-spire-and-iam-roles-anywhere/" aria-label="Next" aria-describedby="left_title"><span class="arrow">←</span>&nbsp;Next</a>
                <p aria-hidden="true" id="left_title">Connecting GitHub Codespaces to AWS VPN via SPIFFE&#x2F;SPIRE &amp; IAM Roles Anywhere</p></div>
                <div><a href="https://misaac.me/blog/spiffe-spire-secret-sprawl-fix/" aria-label="Prev" aria-describedby="right_title">Prev&nbsp;<span class="arrow">→</span></a>
                <p aria-hidden="true" id="right_title">The Secret Problem Isn’t Secrets – It&#x27;s Identity</p></div>
            </nav>
        
        

        
            
            
            

            
        
            
            
            

            
        
            
            
            

            
        
            
            
            

            
        
        

    </article>
</main>

    <div id="button-container">
        
        
            <div id="toc-floating-container">
                <input type="checkbox" id="toc-toggle" class="toggle"/>
                <label for="toc-toggle" class="overlay"></label>
                <label for="toc-toggle" id="toc-button" class="button" title="Toggle Table of Contents">
                    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 -960 960 960"><path d="M414.82-193.094q-18.044 0-30.497-12.32-12.453-12.319-12.453-30.036t12.453-30.086q12.453-12.37 30.497-12.37h392.767q17.237 0 29.927 12.487 12.69 12.486 12.69 30.203 0 17.716-12.69 29.919t-29.927 12.203H414.82Zm0-244.833q-18.044 0-30.497-12.487Q371.87-462.9 371.87-480.45t12.453-29.92q12.453-12.369 30.497-12.369h392.767q17.237 0 29.927 12.511 12.69 12.512 12.69 29.845 0 17.716-12.69 30.086-12.69 12.37-29.927 12.37H414.82Zm0-245.167q-18.044 0-30.497-12.32t-12.453-30.037q0-17.716 12.453-30.086 12.453-12.369 30.497-12.369h392.767q17.237 0 29.927 12.486 12.69 12.487 12.69 30.203 0 17.717-12.69 29.92-12.69 12.203-29.927 12.203H414.82ZM189.379-156.681q-32.652 0-55.878-22.829t-23.226-55.731q0-32.549 23.15-55.647 23.151-23.097 55.95-23.097 32.799 0 55.313 23.484 22.515 23.484 22.515 56.246 0 32.212-22.861 54.893-22.861 22.681-54.963 22.681Zm0-245.167q-32.652 0-55.878-23.134-23.226-23.135-23.226-55.623 0-32.487 23.467-55.517t56.12-23.03q32.102 0 54.721 23.288 22.62 23.288 22.62 55.775 0 32.488-22.861 55.364-22.861 22.877-54.963 22.877Zm-.82-244.833q-32.224 0-55.254-23.288-23.03-23.289-23.03-55.623 0-32.333 23.271-55.364 23.272-23.03 55.495-23.03 32.224 0 55.193 23.288 22.969 23.289 22.969 55.622 0 32.334-23.21 55.364-23.21 23.031-55.434 23.031Z"/></svg>
                </label>
                <div class="toc-content">
                    

<div class="toc-container">
    

    <ul>
        
            
            
                <li><a href="https://misaac.me/blog/grant-aws-access-to-codespaces-via-spiffe-spire-iam-roles-anywhere/#preamble">Preamble</a>
                    
                </li>
            
        
            
            
                <li><a href="https://misaac.me/blog/grant-aws-access-to-codespaces-via-spiffe-spire-iam-roles-anywhere/#terminology">Terminology</a>
                    
                </li>
            
        
            
            
                <li><a href="https://misaac.me/blog/grant-aws-access-to-codespaces-via-spiffe-spire-iam-roles-anywhere/#what-s-our-goal">What&#x27;s our goal?</a>
                    
                </li>
            
        
            
            
                <li><a href="https://misaac.me/blog/grant-aws-access-to-codespaces-via-spiffe-spire-iam-roles-anywhere/#setting-up-our-public-key-infrastructure-pki">Setting up our Public Key Infrastructure (PKI)</a>
                    
                </li>
            
        
            
            
                <li><a href="https://misaac.me/blog/grant-aws-access-to-codespaces-via-spiffe-spire-iam-roles-anywhere/#setting-up-iam-roles-anywhere">Setting up IAM Roles Anywhere</a>
                    
                </li>
            
        
            
            
                <li><a href="https://misaac.me/blog/grant-aws-access-to-codespaces-via-spiffe-spire-iam-roles-anywhere/#setting-up-the-spire-server">Setting up the SPIRE Server</a>
                    
                        <ul>
                            
                                
                                    <li><a href="https://misaac.me/blog/grant-aws-access-to-codespaces-via-spiffe-spire-iam-roles-anywhere/#architecture">Architecture</a>
                                        
                                    </li>
                                
                            
                                
                                    <li><a href="https://misaac.me/blog/grant-aws-access-to-codespaces-via-spiffe-spire-iam-roles-anywhere/#prerequisites">Prerequisites</a>
                                        
                                    </li>
                                
                            
                                
                                    <li><a href="https://misaac.me/blog/grant-aws-access-to-codespaces-via-spiffe-spire-iam-roles-anywhere/#setting-up-route53-and-the-network-load-balancer">Setting up Route53 and the Network Load Balancer</a>
                                        
                                    </li>
                                
                            
                                
                                    <li><a href="https://misaac.me/blog/grant-aws-access-to-codespaces-via-spiffe-spire-iam-roles-anywhere/#setting-up-our-ecs-service">Setting up our ECS Service</a>
                                        
                                            <ul>
                                                
                                                    
                                                        <li><a href="https://misaac.me/blog/grant-aws-access-to-codespaces-via-spiffe-spire-iam-roles-anywhere/#the-cluster">The cluster</a>
                                                            
                                                        </li>
                                                    
                                                
                                                    
                                                        <li><a href="https://misaac.me/blog/grant-aws-access-to-codespaces-via-spiffe-spire-iam-roles-anywhere/#the-log-groups-and-iam-roles">The log groups and IAM roles</a>
                                                            
                                                        </li>
                                                    
                                                
                                                    
                                                        <li><a href="https://misaac.me/blog/grant-aws-access-to-codespaces-via-spiffe-spire-iam-roles-anywhere/#the-iam-policies">The IAM Policies</a>
                                                            
                                                        </li>
                                                    
                                                
                                                    
                                                        <li><a href="https://misaac.me/blog/grant-aws-access-to-codespaces-via-spiffe-spire-iam-roles-anywhere/#the-spire-server-config">The SPIRE Server Config</a>
                                                            
                                                        </li>
                                                    
                                                
                                                    
                                                        <li><a href="https://misaac.me/blog/grant-aws-access-to-codespaces-via-spiffe-spire-iam-roles-anywhere/#the-spire-server-ecs-task-definition">The SPIRE Server ECS Task Definition</a>
                                                            
                                                        </li>
                                                    
                                                
                                                    
                                                        <li><a href="https://misaac.me/blog/grant-aws-access-to-codespaces-via-spiffe-spire-iam-roles-anywhere/#the-security-groups">The security groups</a>
                                                            
                                                        </li>
                                                    
                                                
                                                    
                                                        <li><a href="https://misaac.me/blog/grant-aws-access-to-codespaces-via-spiffe-spire-iam-roles-anywhere/#the-ecs-service">The ECS Service</a>
                                                            
                                                        </li>
                                                    
                                                
                                            </ul>
                                        
                                    </li>
                                
                            
                                
                                    <li><a href="https://misaac.me/blog/grant-aws-access-to-codespaces-via-spiffe-spire-iam-roles-anywhere/#verifiying-the-deployment">Verifiying the deployment</a>
                                        
                                    </li>
                                
                            
                        </ul>
                    
                </li>
            
        
            
            
                <li><a href="https://misaac.me/blog/grant-aws-access-to-codespaces-via-spiffe-spire-iam-roles-anywhere/#setting-up-the-spire-agent">Setting up the SPIRE Agent</a>
                    
                        <ul>
                            
                                
                                    <li><a href="https://misaac.me/blog/grant-aws-access-to-codespaces-via-spiffe-spire-iam-roles-anywhere/#the-agent-config">The Agent Config</a>
                                        
                                    </li>
                                
                            
                                
                                    <li><a href="https://misaac.me/blog/grant-aws-access-to-codespaces-via-spiffe-spire-iam-roles-anywhere/#node-attestation-with-a-join-token">Node Attestation with a join token</a>
                                        
                                    </li>
                                
                            
                                
                                    <li><a href="https://misaac.me/blog/grant-aws-access-to-codespaces-via-spiffe-spire-iam-roles-anywhere/#creating-a-registration-entry">Creating a registration entry</a>
                                        
                                    </li>
                                
                            
                        </ul>
                    
                </li>
            
        
            
            
                <li><a href="https://misaac.me/blog/grant-aws-access-to-codespaces-via-spiffe-spire-iam-roles-anywhere/#requesting-a-spiffe-svid-a-k-a-certificate">Requesting a SPIFFE SVID, a.k.a certificate</a>
                    
                </li>
            
        
            
            
                <li><a href="https://misaac.me/blog/grant-aws-access-to-codespaces-via-spiffe-spire-iam-roles-anywhere/#use-a-spiffe-svid-to-obtain-aws-credentials-via-iam-roles-anywhere">Use a SPIFFE SVID to obtain AWS credentials via IAM Roles Anywhere</a>
                    
                </li>
            
        
    </ul>
</div>


                </div>
            </div>
        

        
        

        
        <a href="#" id="top-button" class="no-hover-padding" title="Go to the top of the page">
            <svg viewBox="0 0 20 20" fill="currentColor"><path d="M3.293 9.707a1 1 0 010-1.414l6-6a1 1 0 011.414 0l6 6a1 1 0 01-1.414 1.414L11 5.414V17a1 1 0 11-2 0V5.414L4.707 9.707a1 1 0 01-1.414 0z"/></svg>
        </a>
    </div>


<span id="copy-success" class="hidden">
        Copied!
    </span>
    <span id="copy-init" class="hidden">
        Copy code to clipboard
    </span>
    <script defer src="https://misaac.me/js/copyCodeToClipboard.min.js"></script>
    </div>
    <footer>
    <section>
        <nav class="socials nav-navs">
        </nav>

        
        <nav class="nav-navs">
        </nav>

        <div class="credits">
            <small>
                
    
    
    
    
        
    
        
    

    

    
    
    

    
    
    <p><p>© 2025 Isaac M • Except where otherwise noted , content on this site is licensed under a <a href="https://creativecommons.org/licenses/by-sa/4.0/">CC BY-SA 4.0</a> license.</p>
</p>

                </small>
        </div>
    </section>

    </footer>

</body>

</html>
